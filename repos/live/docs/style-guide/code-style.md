# Comments

## TODOs

- Include your Github username in brackets.
- Indent multi-line comments by two space from the first char (3 spaces from the last slash).
- WebStorm handles multi-line TODOs.

```js
// TODO(vjpr): Fix this.
//   Indent by two space from the first character.
const a = 1
```

### Useful aliases

- `todo` -> `// TODO(vjpr):`
- `TODO` -> `TODO(vjpr):`


## Dividers (JavaScript)

- If you need to divide up a large function or a file use dividers.
- We use a slash instead of something like `// ---` because it appears thicker and clearer.

```js
export default function foo() {
  
  // Foo
  ////////////////////
  
  const a = 1
  
  // Bar
  ////////////////////
  
  const b = 1
  
  ////////////////////
  
  bar()
  
}

////////////////////////////////////////////////////////////////////////

// This function could potentially be split into another file at some point - before we do that we can just throw it down here.
// We add a divider to separate our main React component or function from any utility functions.
// In React you often have to scroll down to find the render (`return`) statement and having a divider helps us find it.
function bar() {
  
}

```

### Useful aliases

- `///` -> `////...` (80 slashes)
- `////` => `////...` (20 slashes)

## Dividers (other languages)

In files using `#` to start a comment we use dashes because `#####` is ugly ;)

```
# ----------------------------------------------------------------------
# Workflows
# ----------------------------------------------------------------------
```

## Line comments

If there is no space between consecutive lines and your line comment applies only to a single line, add two dashes at the end of the block that the comment applies to `// --`.

```js
// TODO(vjpr): Fix this.
const a = 'a'
const b = 'a'
// --
const c = 3
```

```js
// TODO(vjpr): Fix this.
const a = 'b'

const b = 2

const c = 3
```

#### Line comments always end in a full-stop unless they are "headings"

```js
// This is a bad comment

// This is a good comment.

// This is a heading with no full-stop
////////////////////
```

## Ordered lists in comments

```js
function foo() {
  
}
```

# Exports

Use named exports rather than default.

With named we can easily export a module flat with barrel files.

Defaults are trickier to export.

_index.js_

```
// Generated by barrelsby.

export * from './foo'
```

_foo.js_

```
export class Foo {

}
```

```
import {Foo} from 'index'
```

See also: React naming conventions.

# Naming

## Files

`kebab-case`

Why? https://stackoverflow.com/a/44882336/130910

React classes should be `CamelCase`.

##

We follow Nest.js conventions.

# Imports

#### Put all code in `src`

#### Don't use relative imports that reference files upwards from the current folder

Prefer the `@src` alias most of the time.

TODO: Decide if we should ever use relative file references.

```
// good
import foo from '@src/modules/foo'

// ok
import foo from './foo'

//bad
import foo from '../modules/foo'
```

#### Keep imports at the top

Why? When you are moving files around you want to easily see dependencies.

```js

// bad

function foo() {
  
}

////////////////////////////////////////////////////////////////////////

// This is bad. There is an ESLint rule that will error on this and for good reason.
import baz from 'baz'

function bar() {
  foo()
}
```

## Re-exporting (barrel files)

We use `barrelsby` to generate ["barrel" files](https://basarat.gitbook.io/typescript/main-1/barrel) whenever we need to iterate over a bunch of modules/classes/files.

We never access files dynamically.

Why? We lose IDE navigation and type checking.

**Bad**
```js
const models = fs.readDirSync('./models')
```

Start our app like so: `concurrently "barrelsby -sqSD -d src/models" "index.js"` which generates this file:

**Good**

```js
/**
 * @file Automatically generated by barrelsby.
 */

export * from './company-solution.model'
export * from './company-tag.model'
export * from './company.model'
```

```js
import * as models from 'src/models'
models.map((model) => { // ... })
```

## Dynamic imports

If you do need to access something dynamically add a reference to the filename so that if it get's refactored the IDE will know about it. Never use `../`.

```js
// ../../bar.js
const dirname = _dirname
export default dirname

// foo.js
import dirname from '@src/bar'
path.join(dirname, 'something') 
```

### Performance

Can be bad for frontend. Maybe reconsider our usage of it.

https://twitter.com/iamakulov/status/1331551351214645251?s=21

# Function code ordering

Make use of [function hoisting](https://developer.mozilla.org/en-US/docs/Glossary/Hoisting).

As you read a function it should be clear what is happening using self-documenting functions which group functionality together.

```js
// good
function foo() {
  
  doSomething()
  doSomethingElse()
  
  ////////////////////
  
  function doSomething() {
    // ...
  }
  
  function doSomethingElse() {
    // ...
  }
  
}
```

You could also move the functions outside of the function.

```js
// good
function foo() {
  
  doSomething()
  doSomethingElse()
  
}

////////////////////////////////////////////////////////////////////////
  
function doSomething() {
  // ...
}

function doSomethingElse() {
  // ...
}
```

```js
// bad
function foo() {
  
  // Comment needed to explain what is going on.
  const arr = []
  for (const foo of foos) {
    arr.push(foo)
  }
  
  // Comment explaining the next thing.
  // Also makes use of a variable above that is not wrapped in a function named for what it is actually doing.
  console.log(arr)
  
}

```

```js
// bad
function foo() {
  
  function doSomething() {
    // ...
  }
  
  doSomething()
  
  function doSomethingElse() {
    // ...
  }
  
  doSomethingElse()
  
}
```

Anonymous functions are not hoisted so must be defined before the invocation, but then readability decreases.

```js
// bad
function foo() {
  
  const doSomething = ()  => {
    // ...
  }
  
  doSomething()
  
}
```

# Code structure

## Conditionals

#### Use early returns

```js

// bad
if (foo) {
  return 'foo'
} else {
  return 'bar'
}

// good
if (foo) return 'foo'
return 'bar'
```

#### Conditional and immediate return

```js
let ans
if (ans = isFoo()) return ans
if (ans = isBar()) return ans
```

# Line width

- Lines are max 80 wide so you can fit 3 editors and folder structure on a 1920x1200 display.
- Ideally we want files to be 80-100 lines long. This is the lines visible on 1920x1200 (MacBook Retina "More space" resolution, and typical 24" monitors).

# Line breaks

Less lines makes code a lot more readable. This doesn't mean go crazy with one-liners but it does mean try to avoid line breaks by naming variables shorter sometimes.

Below you can see that the function invocation is the most important control flow so its nice to keep it on one line.

```js
// good
const configWithPgDatabase = {...dbConfig, database: 'postgres'}
const db = await connect({database, env, config: configWithPgDatabase})

// bad
const configWithPostgresDatabase = {...dbConfig, database: 'postgres'}
// The function invocation is less clear when we add a line break.
const db = await connect({
  database, 
  env, 
  config: configWithPostgresDatabase
})
```

# Naming variables

#### Be explicit, but don't go over the top.

Favour self-documenting code (variables and function names that explain what they are), rather than lots of comments.

```js
// good
// We do this because we can't drop the database we are connected to.
const configWithPgDatabase = {...dbConfig, database: 'postgres'}
const db = await connect({database, env, config: configWithPgDatabase})

// bad
// This is config object that uses the default 'postgres' database.
const config = {...dbConfig, database: 'postgres'}
const db = await connect({database, env, config})
```

#### Use `{foo, bar}` instead of `{foo: 'foo', bar: barSomething}` as much as possible

This can be a balancing act.

# Packages

A package is a folder with a `package.json` file.

IMPORTANT: Always add a `tsconfig.json` file to your package or TypeScript auto-import won't work.

Use this format:

```
{
  "extends": "./node_modules/@live/tsconfig/tsconfig.json",
  "compilerOptions": {
    "rootDir": ".",
    "jsx": "react",
    "baseUrl": "src",
  }
}

```

IMPORTANT: `baseUrl` must be explicitly defined in this package's `tsconfig.json` file because it resolves the specified directory relative to the `tsconfig.json`. It cannot be specified inside a file in the `extends` property.

You will need to add `@live/tsconfig` as a dependency.

IMPORTANT: `tsconfig.json` is only used for IDE support as we compile our TS code using Babel which does not even read this file.

### `rootDir`

https://www.typescriptlang.org/tsconfig#rootDir

> > Default: The longest common path of all non-declaration input files. If composite is set, the default is instead the directory containing the tsconfig.json file.

By default it will be set to `src`, which makes sense if we are transpiling to disk in another directory.

Because we transpile with babel on-the-fly and never compile to another disk location, we just access them directly.

We could do some remapping with babel but then it adds complexity. So we prefer that our import paths map directly to the file struture on disk, and if we want to drop the `src`, then we would add files that explicitly export internal files using something like barrel files.

When auto-importing this is the behavior if we don't set `rootDir = '.'`.

```
import bar from '@org/foo/bar' <- actual
import bar from '@org/foo/src/bar' <- expected
```

I wonder if `rootDir` is resolved from the resolved `tsconfig.json` loocation like `baseUrl` is...probably...but I need to check this.

## paths without `baseUrl`

https://devblogs.microsoft.com/typescript/announcing-typescript-4-1/#paths-without-baseurl

## When do split something into a package?

The function extracting process goes as follows:

Take a block of code.

1. Create function
2. Create file for function

# Exports

Use named exports of default exports. Makes it easier to use TypeScript auto-import.

# Require

If you need to do something like:

```js
const migrationsPath = join(__dirname, '../../migrations', databaseGroup)
```

Instead do:

```js
// migrations/index.ts
export default __dirname

import '@src/migrations'
const migrationsPath = join(__dirname, '../../migrations', databaseGroup)
```

Then if the file is moved around the reference will still be correct.

# ESLint

## Ignoring lines

```
// @ts-ignore
// eslint-disable-next-line import/no-unresolved
import OriginalFooter from '@theme-original/Footer'
```

---

# `@live/simple-cli-helper`

`simple-cli-helper` allows you to call code anywhere in the codebase and it will be transpiled.

If third-party non-transpiled code such as configs are calling your code, then you should use it.

You would usually get "Cannot import outside of a module" errors otherwise.

---

# `console.log`

Wrap identifiers in single quotes. Normally `\`` is the right approach in markdown it is too tricky when using template strings.

```
// good
console.log(`Running depcheck for '${pkgName}'`)
```

---

# Tracking down console.log messages

```
ENABLE_CONSOLE_CALLER=1 npm run start
```
# Run asynchronous commands synchronously by putting them in a separate process

Useful for tooling.

- Just use execSync.
- https://github.com/ForbesLindesay/sync-rpchttps://stackoverflow.com/questions/42009968/is-it-possible-to-run-async-code-in-a-babel-plugin-visitor#:~:text=2%20Answers&text=Babel's%20API%2C%20for%20example%20babel,Babel%20itself%20is%20fully%20synchronous.

# Wallaby

compilers vs preprocessors
https://wallabyjs.com/docs/config/compilers.html

---

# File names

Provide examples when using filenames in line comments. See that babel plugin I wrote.
